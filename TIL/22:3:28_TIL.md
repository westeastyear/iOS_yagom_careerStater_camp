# TIL (Today I Learned)
3월 28일 (월)

활동학습을 하면서 팀원과 정리한 내용입니다.

## 메모리의 구조
> - **코드(code) 영역**
>    * 실행할 프로그램의 코드가 저장되는 영역으로, 텍스트 영역이라고도 부릅니다.
>        - 프로그램이 시작하고 끝날 때까지 메모리에 남아있습니다.
>        - 컴파일된 기계어가 들어갑니다.
>        - CPU는 코드 영역에 저장된 명령어를 가져가서 처리합니다.
> - **데이터(data) 영역**
>    * 프로그램의 전역 변수와 정적(static) 변수, 문자열 상수가 저장되는 영역입니다.
>        - 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
> - **스택(stack) 영역** 
>    * 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.
>        - 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸합니다. 
>        - 스택 영역에 저장되는 함수의 호출 정보를 stack frame이라고 합니다.
>        - push로 데이터를 저장하고, pop으로 데이터를 인출합니다. Last-in-First-Out(후입선출)방식에 따라 동작합니다.
>        - 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.
>        컴파일 시에 크기가 결정됩니다.
> - **힙(heap) 영역**
>    * 사용자가 직접 관리할 수 있고, 해야만하는 메모리 영역입니다.
>        - 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.
>        - 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.
>        - 런타임시에 크기가 결정되며 이 공간에 메모리 할당하는 것을 동적할당이라고 부릅니다.
>        - new연산자(또는 malloc())를 통해 할당하고, delete연산자(또는 free())를 통해서 해제합니다.


# ARC
### ARC란?
> - Automatic Reference Counting
> - 사용되지 않는 클래스 인스턴스를 자동으로 메모리를 해제해주는 역할을 합니다. 
> - 자동으로 구문을 분석해서 적절하게 레퍼런스 감소 코드 삽입해 주어, 실행 중에 별도의 메모리 관리가 이루어 지지 않도록 합니다.

새 인스턴스를 만들때마다 ARC는 정보를 저장하기 위해 메모리 청크를 할당(chunk of memory)합니다. 이 메모리에는 해당 인스턴스에 관련된 저장 프로퍼티값과 함께, 인스턴스 타입에 대한 정보를 보유합니다.

인스턴스가 필요하지 않다면 ARC는 메모리를 해제하여 다른 용도로 사용하게 됩니다. 

사용중인 인스턴스를 해제하면 해당 인스턴스의 프로퍼티에 액세스하거나 메소드를 호출할 수 없고, 앱이 충돌할 가능성이 커집니다. 

인스턴스가 필요한 데 사라지지 않도록 하기 위해, ARC는 인스턴스를 참조하는 프로퍼티, 상수, 변수의 수를 추적합니다. 하나의 참조가 존재하는한 할당 해제하지 않습니다.

클래스 인스턴스를 프로퍼티, 상수, 변수에 할당할 때마다 기본적으로 “Strong” 참조를 하며, Strong 참조가 남아있는한 해제를 허용하지 않습니다.

> - 다른 인스턴스의 할당을 먼제 해제할 수 있는 경우에는 weak를 사용합니다.
> - 다른 인스턴스의 수명이 같거나 긴 경우에는 unowned를 사용합니다.

## weak

weak참조는 참조하는 인스턴스를 강하게 유지하지 않기 때문에 참조하는 동안 해당 인스턴스가 할당 해제될 수 있습니다. 실행시에 값을 nil로 변경할 필요가 있기 때문에 항상 옵셔널 타입의 변수로 선언됩니다.

## **Unowned**

항상 값을 가지고 있을 것으로 예상됩니다. 값을 unowned로 표시한다고 해서 옵셔널타입이 되는것은 아니며, ARC는 unowned 참조의 값을 nil로 설정하지 않습니다. 

항상 할당 해제되지 않는 인스턴스를 참조하는 경우에만 unowned참조를 사용하십시오.

인스턴스가 할당해제된 후 unowned참조의 값에 액세스하려고 하면 런타임 오류가 발생합니다.

### ARC 이전의 메모리 관리는 어땠을까?
> - 2011년도부터 Objective-C 메모리 관리 방식이 MRC 에서 ARC 로 대체되었다.
> - MRC(Manual Reference Counting) 는 MRR(Manual Retain-Release) 이라고도 불렸다.
> - RC 의 증가와 감소를 명시적으로 호출하여야 했다.
> - alloc, new, copy, mutableCopy, retain 등으로 RC 증가
> - release 로 RC 감소
> - 최종 Reference Count가 0이 되면 매모리 해제

### ARC를 이해해야 하는 이유는 무엇이 있을까?
> - 인스턴스가 의도한 바와 다르게 메모리에서 해제되는경우 
> - 인스턴스 끼리 참조하게 되는 경우 의도한 바와 다르게 메모리해제가 되지 않는경우 원인을 파악하기위해
> - 순환참조를 예방하기 위해





### 언제 구조체를 선택하고 언제 클래스를 선택해야할까?

**구조체를 선택할때**
> - 애플에서는 구조체로 설계하기를 권하고 있다.
> - heap 에 저장되는 클래스와 달리 구조체는 stack 에 저장되어 속도가 더 빠르다.

**클래스를 선택할때**
> - 꼭 클래스의 기능이 필요로 할때 클래스를 사용한다.
> - Objective-C와 상호운용이 필요할 때 Class를 사용한다.
> - 구조체의 저장 프로퍼티 값이 게속 변경되어 mutating 키워드를 많이 사용하여 메모리를 class 보다 많이 사용할때 클래스 를 사용한다.

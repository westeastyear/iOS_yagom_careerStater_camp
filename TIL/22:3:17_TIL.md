# TIL (Today I Learned)
3월 17일 (목)

## 인터페이스란 무엇인가요?
> - 인터페이스라는 용어 자체는 어떤 측면으로 보느냐에 따라 대답이 달라집니다. 
> - 광역적인 의미일까? 언어적일까? 특정 언어에 속한 기능일까? 
> - 접점이라는 뜻이기 때문에 어떠한 접점이든 인터페이스라고 할 수 있습니다. 객체간의 통신 약속, 통신을 하기 위한 서로간의 약속이라고 볼 수 있겠습니다. 
> - 인터페이스는 프로토콜이 아니고, swift에서 프로토콜의 기능으로 구현할 수 있다!입니다. 
> - 만약 회사에서 비슷한 질문이 들어왔다면? → 추측해서 대답을 한다면 잘못 대답할 수가 있습니다. → 그러면 물어보는 겁니다. 어디에서 사용하는 인터페이스 일까요?


# S.O.L.I.D

- **S** (Single Responsibility Principle) : 단일 책임 원칙
- **O** (Open/Close Principle) : 개방/폐쇄 원칙
- **L** (Liscov Substitution Principle) : 리스코브 치환 원칙
- **I** (Interface Segregation Principle) : 인터페이스 분리 원칙
- **D** (Dependency Inversion Principle) : 의존성 역전 원칙

이 다섯가지 원칙을 적용한다면

- 쉽게 변경이 가능한 유연한 코드를 가지게 된다. 이것은 재사용과 유지 관리가 가능하다.
- 그렇게 개발된 소프트웨어는 안정되고, 탄탄하며 확장성이 뛰어날 것이다.(쉽게 새로운 기능을 추가할 수 있다.)
- 디자인 패턴의 사용과 함께, 응집력이 높고(시스템의 요소가 밀접하게 연관) 결합도가 낮은(요소들 간의 의존도가 낮음) 소프트웨어를 만들 수 있다.


## Single Responsibility Principle (단일 책임 원칙)

> **클래스나 함수를 설계할 때, 각 단위들은 단 하나의 책임만을 가져야 한다는 원칙입니다.** 
> 
> 소프트웨어에서 어떠한 하나의 수정이 필요할 때 하나의 유형 또는 함수만 수정해도 작동하도록 설계해야 하는 것입니다. 

    <책임은 변경의 이유!>
    * 변경을 위해 수정이 되려면 많은 내용이 수정 → 응집도가 높다
    * 변경을 위한 이유가 같은 것들끼리 모이자
    * 수정은 한곳에 집중되야함 → 여러 곳에 걸친 수정이 안이루어짐 → 결합도 낮음

## Open/Close Principle (개방/폐쇄 원칙)

> **확장에는 열려있으나 변경에는 닫혀있어야 한다는 원칙입니다.** 
>
> 어떤 기능을 추가할 때, 기존의 코드는 만지지 않고 새로 동작하는 기능에 대해서만 코드가 작성이 되어야 합니다.

    * 변경이 전파되지 않으면서 새로운 코드를 추가할 수 있는 구조
    * 기존 코드의 수정이 없으니 재검증이 필요없이 소프트웨어를 키워갈 수 있다.

## Liscov Substitution Principle (리스코프 치환 원칙)

> **부모(super class)로 동작하는 곳에서 자식(sub class)를 넣어주어도 대체가 가능해야한다는 원칙입니다.** 
>
> 자식 클래스를 구현할 때, 기본적으로 부모 클래스의 기능이나 능력들을 물려받습니다. 여기서 자식 클래스는 동작을 할 때, 부모 클래스의 기능들을 제한하면 안된다는 뜻입니다. 즉, 부모 클래스의 타입에 자식 클래스의 인스턴스를 넣어도 똑같이 동작하여야 합니다. 


## Interface Segregation Principle (인터페이스 분리 원칙)

> **인터페이스를 일반화하여 구현하지 않는 인터페이스를 채택하는 것보다 구체적인 인터페이스를 채택하는 것이 더 좋다는 원칙입니다.** 
> 
> 인터페이스를 설계할 때, 굳이 사용하지 않는 인터페이스는 채택하여 구현하지 말고 오히려 한 가지의 기능만을 가지더라도 정말 사용하는 기능만을 가지는 인터페이스로 분리하라는 것입니다.


## Dependency Inversion Principle (의존성 역전 원칙)

> **상위 모듈이 하위 모듈에 의존하면 안되고 두 모듈 모두 추상화에 의존하게 만들어야 한다는 원칙입니다.**
>
> 어떤 상위의 모듈에서 하위 모듈을 가지고 있을 때, 상위 모듈의 기능이 하위모듈에 의존해서 기능을 수행하면 안된다는 뜻입니다. 
>
> 추상화를 진행하여 각각의 모듈에 더 추상화된 것에 의존하게 만들어야 한다는 뜻입니다. 이렇게 코드를 설계해야 재사용에도 유용하고 하나를 수정했을 때 더욱 수정사항이 많이 없는 훌륭한 프로그램을 설계할 수 있게 됩니다.
>
> ### Dependency Injection (의존성 주입)
>
> DIP 원칙은 나중에 Uint Test를 진행할 때, 더욱 중요하게 될 원칙입니다. 여기서 **의존성 주입**이라는 용어를 사용하게 됩니다. 
> **상위 모듈에 어떤 하위 모듈을 사용할 때, 상위 모듈에서 직접적으로 하위 모듈을 초기화하지 않고 외부에서 하위 모듈을 초기화 할 수 있게 하라는 뜻**입니다. 
> 그리고 이 상위 모듈, 하위 모듈은 모두 추상화된 객체에 의존할 수 있게 해야 합니니다. **외부에서 내부의 변수를 초기화해서 의존관계를 가지는 경우**를 의존성 주입이라고 합니다.
